{"ast":null,"code":"import _objectSpread from\"/home/bclason/projects/spanish_app/flash_vocab/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";import{useNavigate,useLocation}from'react-router-dom';import{useState,useEffect}from'react';import{DndContext}from'@dnd-kit/core';import Droppable from'../hooks/droppable';import Draggable from'../hooks/draggable';import config from'../config';import{jsx as _jsx,jsxs as _jsxs}from\"react/jsx-runtime\";export default function Chunking(){const navigate=useNavigate();const{state}=useLocation();const listId=state===null||state===void 0?void 0:state.listId;const listName=state===null||state===void 0?void 0:state.listName;const[cards,setCards]=useState([]);const[containers,setContainers]=useState([]);const[cardPositions,setCardPositions]=useState({});// Track which container each card is in\nconst[swapped,setSwapped]=useState(false);// Fetch cards from the backend\nuseEffect(()=>{if(!listId)return;fetch(\"\".concat(config.API_BASE_URL,\"/lists/\").concat(listId,\"/cards\")).then(res=>res.json()).then(data=>{if(data&&Array.isArray(data)){setCards(data);// Create groups based on number of cards (aim for 4-5 cards per group)\nconst numCards=data.length;const cardsPerGroup=4;const numGroups=Math.ceil(numCards/cardsPerGroup);const groupIds=Array.from({length:numGroups},(_,i)=>i+1);// 1, 2, 3, 4, etc.\nsetContainers(groupIds);// Initialize card positions based on existing chunk_id from database\nconst initialPositions={};data.forEach(card=>{initialPositions[card.id]=card.chunk_id;});setCardPositions(initialPositions);}else{console.error('Expected array but got:',data);setCards([]);}}).catch(err=>{console.error('Failed to fetch cards',err);setCards([]);});},[listId]);const handleDragEnd=async event=>{const{active,over}=event;if(over){console.log('chunk_id on drop:',over.id);// Determine the chunk_id to save (0 for unassigned, over.id for groups)\nconst chunkId=over.id==='unassigned'?0:over.id;// Check if the target container already has 5 cards (if it's not the unassigned area)\nif(over.id!=='unassigned'){const cardsInTarget=Object.values(cardPositions).filter(pos=>pos===over.id).length;if(cardsInTarget>=6){alert('Groups can have a maximum of 6 cards');return;// Don't allow the drop\n}}// Always update the database with the new chunk_id\ntry{const response=await fetch(\"\".concat(config.API_BASE_URL,\"/cards/\").concat(active.id),{method:'PUT',headers:{'Content-Type':'application/json'},body:JSON.stringify({chunk_id:chunkId})});if(!response.ok){console.error('Failed to update card chunk');return;}}catch(error){console.error('Error updating card chunk:',error);return;}// Update the position of the dragged card\nsetCardPositions(prev=>_objectSpread(_objectSpread({},prev),{},{[active.id]:chunkId}));}};const AIsort=async()=>{try{// Extract words based on what's currently displayed (term or translation)\nconst words=cards.map(card=>swapped?card.translation:card.term);if(words.length===0){alert('No cards to sort!');return;}// Send words to backend for AI grouping\nconst response=await fetch(\"\".concat(config.API_BASE_URL,\"/group-words\"),{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({words:words})});if(!response.ok){console.error('Failed to get AI grouping');alert('Failed to get AI grouping. Please try again.');return;}const aiResponse=await response.json();console.log('AI grouping response:',aiResponse);// Parse the AI response and create new card positions\nconst newCardPositions={};const groups=aiResponse.groups||[];// Update containers to match the number of AI-generated groups\nconst numAIGroups=groups.length;const newContainers=Array.from({length:numAIGroups},(_,i)=>i+1);setContainers(newContainers);// First, set all cards to unassigned (0)\ncards.forEach(card=>{newCardPositions[card.id]=0;});// Then assign cards to groups based on AI suggestions\ngroups.forEach((group,groupIndex)=>{const groupId=groupIndex+1;// Groups are numbered 1, 2, 3, etc.\ngroup.forEach(wordFromAI=>{// Find the card that matches this word (based on what was sent to AI)\nconst matchingCard=cards.find(card=>swapped?card.translation===wordFromAI:card.term===wordFromAI);if(matchingCard){newCardPositions[matchingCard.id]=groupId;}});});// Update all cards in the database with their new chunk_ids\nconst updatePromises=cards.map(async card=>{const newChunkId=newCardPositions[card.id];try{const response=await fetch(\"\".concat(config.API_BASE_URL,\"/cards/\").concat(card.id),{method:'PUT',headers:{'Content-Type':'application/json'},body:JSON.stringify({chunk_id:newChunkId})});if(!response.ok){console.error(\"Failed to update card \".concat(card.id));}}catch(error){console.error(\"Error updating card \".concat(card.id,\":\"),error);}});// Wait for all updates to complete\nawait Promise.all(updatePromises);// Update the frontend state\nsetCardPositions(newCardPositions);alert('AI sorting completed successfully!');}catch(error){console.error('Error during AI sorting:',error);alert('An error occurred during AI sorting. Please try again.');}};return/*#__PURE__*/_jsxs(\"div\",{children:[/*#__PURE__*/_jsxs(\"div\",{style:{display:'flex',alignItems:'center',justifyContent:'space-between',padding:'.2rem',fontSize:'1.5rem',flexDirection:'row'},children:[/*#__PURE__*/_jsx(\"button\",{type:\"button\",onClick:()=>navigate('/'),children:\" Home\"}),/*#__PURE__*/_jsx(\"button\",{type:\"button\",onClick:()=>navigate('/medley',{state:{listId,listName}}),children:\" Medley Mode\"})]}),/*#__PURE__*/_jsxs(\"h1\",{style:{textAlign:'center',alignItems:'center',fontSize:'52px',fontWeight:'bolder'},children:[\"Term Chunking: \",listName]}),/*#__PURE__*/_jsx(\"p\",{style:{textAlign:'center',fontSize:'24px',marginLeft:'1.75rem',marginRight:'1.75rem'},children:\"Grouping terms into small related groups or \\\"chunks\\\" can improve memory retention. Manually group terms in chunks of 4-6 or automatically group with AI. Once grouped, practice one chunk at a time in Medley mode.\"}),/*#__PURE__*/_jsxs(\"div\",{style:{display:'flex',flexDirection:'row'},children:[/*#__PURE__*/_jsx(\"div\",{style:{display:'flex',marginLeft:'1.5rem'},children:/*#__PURE__*/_jsx(\"button\",{onClick:AIsort,style:{fontSize:'1.5rem',padding:'0.5rem 1rem'},children:\"AI Sort\"})}),/*#__PURE__*/_jsx(\"div\",{style:{display:'flex',marginLeft:'1rem'},children:/*#__PURE__*/_jsx(\"button\",{onClick:()=>setSwapped(!swapped),style:{fontSize:'1.5rem',padding:'0.5rem 1rem'},children:\"Swap Term and Definition\"})})]}),/*#__PURE__*/_jsx(\"div\",{children:/*#__PURE__*/_jsx(\"div\",{style:{marginTop:'2rem',marginLeft:'.55rem',marginRight:'.55rem'},children:/*#__PURE__*/_jsxs(DndContext,{onDragEnd:handleDragEnd,children:[/*#__PURE__*/_jsxs(\"div\",{style:{marginBottom:'2rem'},children:[/*#__PURE__*/_jsx(\"h3\",{style:{textAlign:'center',marginBottom:'1rem'},children:\"Unassigned Cards\"}),/*#__PURE__*/_jsx(Droppable,{id:\"unassigned\",children:/*#__PURE__*/_jsx(\"div\",{style:{display:'flex',flexWrap:'wrap',justifyContent:'center',gap:'1rem',minHeight:'60px',padding:'1rem'},children:cards.filter(card=>cardPositions[card.id]===0).map(card=>/*#__PURE__*/_jsx(Draggable,{id:card.id,children:/*#__PURE__*/_jsx(\"div\",{children:swapped?card.translation:card.term})},card.id))})})]}),/*#__PURE__*/_jsx(\"div\",{style:{display:'flex',justifyContent:'space-around',gap:'2rem',marginTop:'1rem'},children:containers.map(id=>/*#__PURE__*/_jsxs(\"div\",{style:{flex:1},children:[/*#__PURE__*/_jsxs(\"h4\",{style:{textAlign:'center',marginBottom:'0.5rem'},children:[\"Group \",id]}),/*#__PURE__*/_jsx(Droppable,{id:id,children:/*#__PURE__*/_jsx(\"div\",{style:{minHeight:'200px',padding:'1rem'},children:cards.filter(card=>cardPositions[card.id]===id).map(card=>/*#__PURE__*/_jsx(Draggable,{id:card.id,children:/*#__PURE__*/_jsx(\"div\",{style:{padding:'0.3rem'},children:swapped?card.translation:card.term})},card.id))})})]},id))})]})})})]});}","map":{"version":3,"names":["useNavigate","useLocation","useState","useEffect","DndContext","Droppable","Draggable","config","jsx","_jsx","jsxs","_jsxs","Chunking","navigate","state","listId","listName","cards","setCards","containers","setContainers","cardPositions","setCardPositions","swapped","setSwapped","fetch","concat","API_BASE_URL","then","res","json","data","Array","isArray","numCards","length","cardsPerGroup","numGroups","Math","ceil","groupIds","from","_","i","initialPositions","forEach","card","id","chunk_id","console","error","catch","err","handleDragEnd","event","active","over","log","chunkId","cardsInTarget","Object","values","filter","pos","alert","response","method","headers","body","JSON","stringify","ok","prev","_objectSpread","AIsort","words","map","translation","term","aiResponse","newCardPositions","groups","numAIGroups","newContainers","group","groupIndex","groupId","wordFromAI","matchingCard","find","updatePromises","newChunkId","Promise","all","children","style","display","alignItems","justifyContent","padding","fontSize","flexDirection","type","onClick","textAlign","fontWeight","marginLeft","marginRight","marginTop","onDragEnd","marginBottom","flexWrap","gap","minHeight","flex"],"sources":["/home/bclason/projects/spanish_app/flash_vocab/frontend/src/pages/chunking.js"],"sourcesContent":["import { useNavigate, useLocation } from 'react-router-dom';\nimport { useState, useEffect } from 'react';\nimport { DndContext } from '@dnd-kit/core';\nimport Droppable from '../hooks/droppable';\nimport Draggable from '../hooks/draggable';\nimport config from '../config';\n\n\n\nexport default function Chunking() {\n  const navigate = useNavigate();\n  const { state } = useLocation();\n  const listId = state?.listId;\n  const listName = state?.listName;\n\n  const [cards, setCards] = useState([]);\n  const [containers, setContainers] = useState([]);\n  const [cardPositions, setCardPositions] = useState({}); // Track which container each card is in\n  const [swapped, setSwapped] = useState(false);\n\n  // Fetch cards from the backend\n  useEffect(() => {\n    if (!listId) return;\n    fetch(`${config.API_BASE_URL}/lists/${listId}/cards`)\n      .then(res => res.json())\n      .then(data => {\n        if (data && Array.isArray(data)) {\n          setCards(data);\n          // Create groups based on number of cards (aim for 4-5 cards per group)\n          const numCards = data.length;\n          const cardsPerGroup = 4;\n          const numGroups = Math.ceil(numCards / cardsPerGroup);\n          const groupIds = Array.from({ length: numGroups }, (_, i) => i + 1); // 1, 2, 3, 4, etc.\n          setContainers(groupIds);\n          // Initialize card positions based on existing chunk_id from database\n          const initialPositions = {};\n          data.forEach(card => {\n            initialPositions[card.id] = card.chunk_id;\n          });\n          setCardPositions(initialPositions);\n        } else {\n          console.error('Expected array but got:', data);\n          setCards([]);\n        }\n      })\n      .catch(err => {\n        console.error('Failed to fetch cards', err);\n        setCards([]);\n      });\n  }, [listId]);\n\n  \n  const handleDragEnd = async (event) => {\n    const { active, over } = event;\n    if (over) {\n      console.log('chunk_id on drop:', over.id);\n      // Determine the chunk_id to save (0 for unassigned, over.id for groups)\n      const chunkId = over.id === 'unassigned' ? 0 : over.id;\n      // Check if the target container already has 5 cards (if it's not the unassigned area)\n      if (over.id !== 'unassigned') {\n        const cardsInTarget = Object.values(cardPositions).filter(pos => pos === over.id).length;\n        if (cardsInTarget >= 6) {\n          alert('Groups can have a maximum of 6 cards');\n          return; // Don't allow the drop\n        }\n      }\n      // Always update the database with the new chunk_id\n      try {\n        const response = await fetch(`${config.API_BASE_URL}/cards/${active.id}`, {\n          method: 'PUT',\n          headers: { 'Content-Type': 'application/json' },\n          body: JSON.stringify({ chunk_id: chunkId }),\n        });\n        if (!response.ok) {\n          console.error('Failed to update card chunk');\n          return;\n        }\n      } catch (error) {\n        console.error('Error updating card chunk:', error);\n        return;\n      }\n      // Update the position of the dragged card\n      setCardPositions(prev => ({\n        ...prev,\n        [active.id]: chunkId\n      }));\n    }\n  };\n\n  const AIsort = async () => {\n    try {\n      // Extract words based on what's currently displayed (term or translation)\n      const words = cards.map(card => swapped ? card.translation : card.term);\n      if (words.length === 0) {\n        alert('No cards to sort!');\n        return;\n      }\n      // Send words to backend for AI grouping\n      const response = await fetch(`${config.API_BASE_URL}/group-words`, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ words: words }),\n      });\n      if (!response.ok) {\n        console.error('Failed to get AI grouping');\n        alert('Failed to get AI grouping. Please try again.');\n        return;\n      }\n      const aiResponse = await response.json();\n      console.log('AI grouping response:', aiResponse);\n      // Parse the AI response and create new card positions\n      const newCardPositions = {};\n      const groups = aiResponse.groups || [];\n      // Update containers to match the number of AI-generated groups\n      const numAIGroups = groups.length;\n      const newContainers = Array.from({ length: numAIGroups }, (_, i) => i + 1);\n      setContainers(newContainers);\n      // First, set all cards to unassigned (0)\n      cards.forEach(card => {\n        newCardPositions[card.id] = 0;\n      });\n      // Then assign cards to groups based on AI suggestions\n      groups.forEach((group, groupIndex) => {\n        const groupId = groupIndex + 1; // Groups are numbered 1, 2, 3, etc.\n        group.forEach(wordFromAI => {\n          // Find the card that matches this word (based on what was sent to AI)\n          const matchingCard = cards.find(card => \n            swapped ? card.translation === wordFromAI : card.term === wordFromAI\n          );\n          if (matchingCard) {\n            newCardPositions[matchingCard.id] = groupId;\n          }\n        });\n      });\n\n      // Update all cards in the database with their new chunk_ids\n      const updatePromises = cards.map(async (card) => {\n        const newChunkId = newCardPositions[card.id];\n        try {\n          const response = await fetch(`${config.API_BASE_URL}/cards/${card.id}`, {\n            method: 'PUT',\n            headers: { 'Content-Type': 'application/json' },\n            body: JSON.stringify({ chunk_id: newChunkId }),\n          });\n          if (!response.ok) {\n            console.error(`Failed to update card ${card.id}`);\n          }\n        } catch (error) {\n          console.error(`Error updating card ${card.id}:`, error);\n        }\n      });\n\n      // Wait for all updates to complete\n      await Promise.all(updatePromises);\n\n      // Update the frontend state\n      setCardPositions(newCardPositions);\n      \n      alert('AI sorting completed successfully!');\n      \n    } catch (error) {\n      console.error('Error during AI sorting:', error);\n      alert('An error occurred during AI sorting. Please try again.');\n    }\n  };\n\n\n  return (\n    <div>\n      {/* Home and Medley Mode buttons */}\n      <div style={{\n        display: 'flex',\n        alignItems: 'center',\n        justifyContent: 'space-between',\n        padding: '.2rem',\n        fontSize: '1.5rem',\n        flexDirection: 'row',\n      }}>\n          <button\n            type=\"button\"\n            onClick={() => navigate('/')}\n          > Home</button>\n          <button\n            type=\"button\"\n            onClick={() => navigate('/medley', { state: { listId, listName } })}\n          > Medley Mode</button>\n      </div>\n\n      {/* Title and List Name */}\n      <h1 style= {{\n        textAlign: 'center',\n        alignItems: 'center',\n        fontSize: '52px',\n        fontWeight: 'bolder',\n      }}>Term Chunking: {listName}</h1>\n\n      {/* Description */}\n      <p style={{\n        textAlign: 'center',\n        fontSize: '24px',\n        marginLeft: '1.75rem',\n        marginRight: '1.75rem',\n      }}>\n        Grouping terms into small related groups or \"chunks\" can improve memory retention. Manually group terms in chunks of 4-6 or automatically group with AI. Once grouped, practice one chunk at a time in Medley mode.\n      </p>\n\n      {/* Buttons */}\n      <div style={{\n        display: 'flex',\n        flexDirection: 'row',\n      }}>\n        <div style={{\n          display: 'flex',\n          marginLeft: '1.5rem'\n          }}>\n          <button onClick={AIsort} style={{ fontSize: '1.5rem', padding: '0.5rem 1rem' }}>\n            AI Sort\n          </button>\n        </div>\n\n        <div style={{\n          display: 'flex',\n          marginLeft: '1rem'\n        }}>\n          <button onClick={() => setSwapped(!swapped)} style={{ fontSize: '1.5rem', padding: '0.5rem 1rem' }}>\n            Swap Term and Definition\n          </button>\n        </div>\n      </div>\n      <div>\n\n      <div style={{ marginTop: '2rem', marginLeft: '.55rem', marginRight: '.55rem' }}>\n        <DndContext onDragEnd={handleDragEnd}>\n          {/* Unassigned cards */}\n          <div style={{ marginBottom: '2rem' }}>\n            <h3 style={{ textAlign: 'center', marginBottom: '1rem' }}>Unassigned Cards</h3>\n            <Droppable id=\"unassigned\">\n              <div style={{ \n                display: 'flex', \n                flexWrap: 'wrap', \n                justifyContent: 'center', \n                gap: '1rem',\n                minHeight: '60px',\n                padding: '1rem'\n              }}>\n                {cards.filter(card => cardPositions[card.id] === 0).map(card => (\n                  <Draggable key={card.id} id={card.id}>\n                    <div>\n                      {swapped ? card.translation : card.term}\n                    </div>\n                  </Draggable>\n                ))}\n              </div>\n            </Droppable>\n          </div>\n\n          {/* Droppable containers */}\n          <div style={{ \n            display: 'flex', \n            justifyContent: 'space-around', \n            gap: '2rem',\n            marginTop: '1rem'\n          }}>\n            {containers.map((id) => (\n              <div key={id} style={{ flex: 1 }}>\n                <h4 style={{ textAlign: 'center', marginBottom: '0.5rem' }}>Group {id}</h4>\n                <Droppable id={id}>\n                  <div style={{ minHeight: '200px', padding: '1rem' }}>\n                    {cards.filter(card => cardPositions[card.id] === id).map(card => (\n                      <Draggable key={card.id} id={card.id}>\n                        <div style={{ padding: '0.3rem'}}>\n                          {swapped ? card.translation : card.term}\n                        </div>\n                      </Draggable>\n                    ))}\n                  </div>\n                </Droppable>\n              </div>\n            ))}\n          </div>\n        </DndContext>\n      </div>\n      </div>\n    </div>\n  );\n}\n\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}